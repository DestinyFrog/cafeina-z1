require"z1.tools.Error"require"z1.tools.Functions"require"z1.types.Atom"require"z1.Config"Handling={tags={},atoms={},ligations={}}function Handling:new()local a={}setmetatable(a,self)self.__index=self;return a end;function Handling:split_params(b,c)local d={}c=c or"%s"for e in b:gmatch("[^"..c.."]+")do table.insert(d,e)end;return d end;function Handling:remove_comment(b)local f=string.find(b,"%-%-")if f then return b:sub(1,f-1)end;return b end;function Handling:handle_line_tag(b)local g=Match_substr(b,"@tag%s%a+"):gsub("@tag%s","")if not g then return end;table.insert(self.tags,g)end;function Handling:handle_line_atom(b)local g=self:remove_comment(b)local h,i=Match_substr(g,"[A-Z][a-z]?")if not h then return nil,Error:new("symbol not found")end;local j,k=Match_substr(g,"[+|-]%d")local l=0;if j then j=j:gsub("[+|-]","")l=tonumber(j)end;local m=Atom:new(h,l)table.insert(self.atoms,m)local n=(k and k or i)+1;local o=b:sub(n)if not o then return end;local p=coroutine.wrap(Split_string)local q=p(o)while q do if not self.ligations[q]then self.ligations[q]=Ligation:new()end;if not self.ligations[q].from then self.ligations[q].from=m;m:add_ligation(self.ligations[q])else self.ligations[q].to=m;m:set_parent(self.ligations[q])end;q=p()end end;function Handling:handle_line_ligation(b)local r=Match_substr(b,"%d+")local function s(t)if t=="c"then return"covalente"elseif t=='d'then return"covalente dativa"elseif t=='h'then return"hidrogênio"elseif t=='i'then return"iônica"end;return nil end;local u=Match_substr(b,"[i|d|h|c];")local v=nil;if u then v=s(u:gsub(";",""))end;local function w(t)if t=="-"then return 1 elseif t=='='then return 2 elseif t=='%'then return 3 end end;local x=Match_substr(b,"[-|=|%%]")local y=w(x)local z=Match_substr(b,"%d+°")local A=nil;if z then local B=string.gsub(z,"°","")A=tonumber(B)end;local C=Match_substr(b,"%b[]")local D=nil;if C then local E,F=Match_substr(C,"-?%d+")local G=Match_substr(C,"-?%d+",F+1)local H=tonumber(E)local I=tonumber(G)D={H,I}end;if not self.ligations[r]then self.ligations[r]=Ligation:new(v,y,A,D)else if v then self.ligations[r].type=v end;if y then self.ligations[r].eletrons=y end;if A then self.ligations[r].angle=A end;if D then self.ligations[r].angle3d=D end end;return nil end;function Handling:handle_line_pattern(b)local J=Match_remove_substr(b,"@p%s[%a|_]+","@p%s")local K=io.open(PATTERN_FOLDER..J..".pre.z1","r")if K==nil then return Error:new("Pattern '"..J.."' not found")end;local L=K:read("*a")K:close()local d=self:split_params(b)local M=self:split_params(d[3],",")for N,O in ipairs(M)do L=L:gsub("$"..N,O)end;return self:handle_sections(L)end;function Handling:handle_line_name(b)local P=Match_remove_substr(b,"@name%s.+","@name%s")self.name=P end;function Handling:handle_sections(g)for b in g:gmatch("[^\n]+")do if string.find(b,"@name$s[%a+]")then self:handle_line_name(b)elseif string.find(b,"@tag %a+")then local Q=self:handle_line_tag(b)table.insert(self.tags,Q)elseif string.find(b,"@p ")then local R=self:handle_line_pattern(b)if R then return R end elseif string.find(b,"[A-Z][a-z]?%s[+|-0-9]?[%s%d+]*")then local m,R=self:handle_line_atom(b)if R then return R end elseif string.find(b,"[%d+|@%a+][%s%d+°]?[%s@type-h|c|d|i]?[%s-|=|%%]?[%s%b[%d+%s%d+]]?")then local R=self:handle_line_ligation(b)if R then return R end end end;return nil end;function Handling:print()print("TAGS:")for S,Q in ipairs(self.tags)do print(Q)end;print("\nATOMS:")for S,m in ipairs(self.atoms)do print(m.symbol)for N,T in ipairs(m.ligations)do print("  "..N.." - "..T.to.symbol)end end;print("\nLIGATIONS:")for U,V in pairs(self.ligations)do print(V.angle)end end