require "os"

---matches a pattern in string
---@param text string
---@param pattern string
---@param from number?
---@return string?, number?
function match_substr(text, pattern, from)
    local start_s, end_s = string.find(text, pattern, from)
    if not start_s then return nil end
    return string.sub(text, start_s, end_s), end_s
end

function split_string(txt, separator)
    for param in txt:gmatch("[^" .. (separator or "%s") .. "]+") do
        coroutine.yield(param)
    end
end

---@class Error
---@field private message string
Error = {}

---Constructs a error object
---@param message string
---@return Error
function Error:new(message)
    local obj = {message = message}
    setmetatable(obj, self)
    self.__index = self
    return obj
end

---Prints the error
function Error:print()
    print("Error: " .. self.message)
end

---@alias LigationType "covalente" | "iônica" | "hidrogênio" | "covalente dativa"

---@alias EletronsType 1 | 2 | 3

---@class Ligation
---@field from Atom?
---@field to Atom?
---@field type LigationType
---@field eletrons EletronsType
---@field angle number?
---@field angle3d number[]
Ligation = {
    from = nil,
    to = nil
}

---Constructs a ligation object
---@param type LigationType?
---@param eletrons EletronsType?
---@param angle number?
---@return Ligation
function Ligation:new(type, eletrons, angle, angle_3d)
    local obj = {
        type = type or "covalente",
        eletrons = eletrons or 1,
        angle = angle,
        angle_3d = angle_3d,
    }
    setmetatable(obj, self)
    self.__index = self
    return obj
end

---Setup a ligation object
---@param type LigationType?
---@param eletrons EletronsType?
---@param angle number?
---@param angle3d number[]?
function Ligation:set(type, eletrons, angle, angle3d)
    if type ~= nil then
        self.type = type
    end

    if eletrons ~= nil then
        self.eletrons = eletrons
    end

    if angle ~= nil then
        self.angle = angle
    end

    if angle3d ~= nil then
        self.angle3d = angle3d
    end
end


---@class Atom
---@field symbol string
---@field charge number
---@field ligations Ligation[]
Atom = {
    last_id = 0
}

---Constructs a atom object
---@param symbol string
---@param charge number?
---@return Atom
function Atom:new(symbol, charge)
    Atom.last_id = Atom.last_id + 1

    local obj = {
        id = Atom.last_id,
        symbol = symbol,
        charge = charge or 0,
        ligations = {},
        x = nil,
        y = nil
    }
    setmetatable(obj, self)
    self.__index = self
    return obj
end

---@class Handling
---@field tags string[]
---@field atoms Atom[]
---@field ligations Ligation[]
Handling = {
    tags = {},
    atoms = {},
    ligations = {}
}

---constructs Handling object
---@return Handling
function Handling:new()
    local obj = {}
    setmetatable(obj, self)
    self.__index = self
    return obj
end

--- Receives a line and split it into params
---@param line string
---@param separator string?
---@return string[]
function Handling:split_params(line, separator)
    local params = {}
    separator = separator or "%s"
    for param in line:gmatch("[^" .. separator .. "]+") do
        table.insert(params, param)
    end
    return params
end

--- Receives a line and remove comment
---@param line string
---@private
---@return string
function Handling:remove_comment(line)
    local comment_position = string.find(line, "%-%-")

    if comment_position then
        return line:sub(1, comment_position - 1)
    end
    return line
end

--- Receives a line (tag) and return tag
---@param line string
---@return (string|nil)
function Handling:handle_line_tag(line)
    local text = match_substr(line, "@tag%s%a+"):gsub("@tag%s","")
    if not text then return end
    table.insert(self.tags, text)
end

--- Receives a line and return a atom object
---@param line string
---@return Atom?, Error?
function Handling:handle_line_atom(line)
    local text = self:remove_comment(line)

    local symbol, end_symbol = match_substr(text, "[A-Z][a-z]?")
    if not symbol then return nil, Error:new("symbol not found") end

    local charge_str, end_charge = match_substr(text, "[+|-%d]")
    local charge = 0
    if charge_str then
        charge_str = charge_str:gsub("[+|-]", "")
        charge = tonumber(charge_str)
    end

    local atom = Atom:new(symbol, charge)
    table.insert(self.atoms, atom)

    local init_ligations = (end_charge and end_charge or end_symbol) + 1
    local ligations_str = line:sub(init_ligations)
    if not ligations_str then return end

    local my_split_string = coroutine.wrap(split_string)
    local ligation_key = my_split_string(ligations_str)

    while ligation_key do
        if not self.ligations[ligation_key] then
            self.ligations[ligation_key] = Ligation:new()
        end

        if not self.ligations[ligation_key].from then
            table.insert(atom.ligations, self.ligations[ligation_key])
            self.ligations[ligation_key].from = atom
        else
            self.ligations[ligation_key].to = atom
        end

        ligation_key = my_split_string()
    end
end

---@param line string
---@return Error?
function Handling:handle_line_ligation(line)
    local ligation_tag = match_substr(line, "[%d+|@%a+]")

    local function str_to_type(p)
        if p == "c" then
            return "covalente"
        elseif p == 'd' then
            return "covalente dativa"
        elseif p == 'h' then
            return "hidrogênio"
        elseif p == 'i' then
            return "iônica"
        end
        return nil
    end

    local type_str = match_substr(line, "@type-[d|i|c|h]")
    local type = nil
    if type_str then
        type = str_to_type(type_str:gsub("@type-", ""))
    end

    local function str_to_eletron(p)
        if p == "-" then return 1
        elseif p == '=' then return 2
        elseif p == '%' then return 3 end
    end

    local eletrons_str = match_substr(line, "[-|=|%%]")
    local eletrons = str_to_eletron(eletrons_str)

    local angle_str = match_substr(line, "%d+°")
    local angle = nil
    if angle_str then
        angle = tonumber(angle_str:sub(1, -1))
    end

    local angle_3d_str = match_substr(line, "%b[]")
    local angle_3d = {angle, 0}
    if angle_3d_str then
        local angle_x_str, end_angle_x = match_substr(angle_3d_str, "%d+")
        local angle_y_str = match_substr(angle_3d_str, "%d+", end_angle_x)

        local angle_x = tonumber(angle_x_str)
        local angle_y = tonumber(angle_y_str)
        angle_3d = {angle_x, angle_y}
    end

    if self.ligations[ligation_tag] == nil then
        self.ligations[ligation_tag] = Ligation:new(type, eletrons, angle, angle_3d)
    else
        self.ligations[ligation_tag]:set(type, eletrons, angle, angle_3d)
    end

    return nil
end

--- Receives a line and return a pattern object
---@param line string
---@return Error?
function Handling:handle_line_pattern(line)
    local text = self:remove_comment(line)

    local params = self:split_params(text)
    local pattern_name = params[2]

    local pattern = io.open("patterns/" .. pattern_name .. ".pre.z1", "r")
    if pattern == nil then
        return Error:new("Pattern '" .. pattern_name .. "' not found")
    end

    local pattern_content = pattern:read("*a")
    pattern:close()

    local pattern_params = self:split_params(params[3], ",")
    for k, pattern_param in ipairs(pattern_params) do
        pattern_content = pattern_content:gsub("$" .. k, pattern_param)
    end

    return self:handle_sections(pattern_content)
end

function Handling:handle_line_name(line)
    return nil --todo
end

--- Receives a text and return a table with tags, atoms and ligations
---@param text string
---@return Error?
function Handling:handle_sections(text)
    for line in text:gmatch("[^\n]+") do
        if string.find(line, "@tag %a+") then
            local tag = self:handle_line_tag(line)
            table.insert(self.tags, tag)
        elseif string.find(line, "@p ") then
            local error = self:handle_line_pattern(line, self.ligations)
            if error then return error end
        elseif string.find(line, "[A-Z][a-z]?%s[+|-0-9]?[%s%d+]*") then
            local atom, error = self:handle_line_atom(line)
            if error then return error end
        elseif string.find(line, "[%d+|@%a+][%s%d+°]?[%s@type-c|d|i]?[%s-|=|%%]?[%s%b[%d+%s%d+]]?") then
            local error = self:handle_line_ligation(line)
            if error then return error end
        end
    end

    return nil
end

function Handling:print()
    print("TAGS:")
    for _, tag in ipairs(self.tags) do
        print(tag)
    end

    print("\nATOMS:")
    for _, atom in ipairs(self.atoms) do
        print(atom.symbol)
        for k, l in ipairs(atom.ligations) do
            print("  " .. k .. " - " .. l.to.symbol .. " " .. l.angle or 0)
        end
    end

    print("\nLIGATIONS:")
    for key, ligation in pairs(self.ligations) do
        local el = '-'
        if ligation.eletrons == 2 then el = '=' elseif ligation.eletrons == 3 then el = '%' end
        print(key .. " | " .. ligation.from.symbol .. " ".. el .." " .. ligation.to.symbol .. " | " .. ligation.type .. " -> " .. (ligation.angle or "") .. " [" .. ligation.angle3d[1] .. ", " .. ligation.angle3d[2] .. "]")
    end
end

Z1_CSS = "z1.css"
Z1_TEMP_SVG = "z1.temp.svg"

---@class Svg
---@field text string
Svg = { content = "" }

---Construct new SVG
---@return Svg
function Svg:new()
    local obj = {}
    setmetatable(obj, self)
    self.__index = self
    return obj
end

---Draw a line between point a (ax, ay) and b (bx, by)
---@param ax number
---@param ay number
---@param bx number
---@param by number
---@param className string?
function Svg:line(ax, ay, bx, by, className)
    if className == nil then className = 'svg-ligation' end
    self.content = string.format('%s<line class="%s" x1="%g" y1="%g" x2="%g" y2="%g"></line>', self.content, className, ax, ay, bx, by)
end

---Draw a circle centered in (x, y) with radius (r)
---@param x number
---@param y number
---@param r number
function Svg:circle(x, y, r)
    self.content = string.format('%s<circle class="svg-eletrons" cx="%g" cy="%g" r="%g"></circle>',
        self.content, x, y, r)
end

---Draw a text (symbol) in (x, y)
---@param symbol string
---@param x number
---@param y number
function Svg:text(symbol, x, y)
    self.content = string.format('%s<text class="svg-element svg-element-%s" x="%g" y="%g">%s</text>',
        self.content, symbol, x, y, symbol)
end

---Draw a subtext (symbol) in (x, y)
---@param symbol string
---@param x number
---@param y number
function Svg:subtext(symbol, x, y)
    self.content = string.format('%s<circle class="svg-element-charge-border" cx="%g" cy="%g"/><text class="svg-element-charge" x="%g" y="%g">%s</text>',
        self.content, x, y, x, y, symbol)
end

---Build all svg in template
---@param width number
---@param height number
---@return string?, Error?
function Svg:build(width, height)
    local css_file = io.open(Z1_CSS, "r")
    if css_file == nil then
        return nil, Error:new("Template 'z1.css' não encontrado")
    end

    local css = css_file:read("*a")
    css = css:gsub("[\n|\t]","")
    io.close(css_file)

    local svg_template_file = io.open(Z1_TEMP_SVG, "r")
    if svg_template_file == nil then
        return nil, Error:new("Template 'z1.temp.svg' não encontrado")
    end

    local svg_template = svg_template_file:read("*a")
    io.close(svg_template_file)

    local svg = string.format(svg_template, width, height, css, self.content)
    return svg, nil
end

---@type string
local plugin = arg[1]

---@type string
local file_name = arg[2]

local f = io.open(file_name, "r")
if not f then
    Error:new("File not found"):print()
    os.exit(1)
end
local content = f:read("*a")
f:close()

local handling = Handling:new()
local error = handling:handle_sections(content)
if error then
    error:print()
    os.exit(1)
end

---@class Plugin
---@field svg Svg
---@field tags string[]
---@field atoms Atom[]
---@field ligations Ligation[]
Plugin = { svg = Svg:new() }

---constroi um novo Plugin padrao
---@param o Handling
---@return Plugin
function Plugin:new(o)
    local obj = {
        tags = o.tags,
        atoms = o.atoms,
        ligations = o.ligations
    }

    setmetatable(obj, self)
    self.__index = self
    return obj
end

StandardPlugin = Plugin:new(handling)

STANDARD_ATOM_RADIUS = 9
STANDARD_LIGATION_SIZE = 30
BORDER = 20

---build the svg
---@return string?, Error?
function Plugin:build()
    self:calcAtomsPosition()

    handling:print()

    local err = self:measureBounds()
    if err ~= nil then return nil, err end

    err = self:drawAtom()
    if err ~= nil then return nil, err end

    err = self:drawLigation()
    if err ~= nil then return nil, err end

    local svg_content, e = self.svg:build(self.width, self.height)
    return svg_content, e
end

---calcula posiçao dos atomos
---@param atom Atom?
---@param dad_atom Atom?
---@param ligation Ligation?
---@param order number
---@param dad_ligation Ligation?
function Plugin:calcAtomsPosition(atom, dad_atom, ligation, order, dad_ligation)
    if atom == nil then atom = self.atoms[1] end
    if atom.already == true then return end

    if ligation and dad_atom then
        if not ligation.angle then
            local default_dad_ligation = dad_ligation and dad_ligation.angle or 0
            local antipodal_pai = default_dad_ligation + 180
            local quantidade_ligacoes = (#dad_atom.ligations) + (dad_ligation and 1 or 0)
            local angulo_fatia = 360 / quantidade_ligacoes
            local angulo = antipodal_pai + angulo_fatia * (order + (not dad_ligation and 1 or 0))
            ligation.angle = math.floor(angulo % 360)
        end
    end

    local x = 0
    local y = 0
    if dad_atom ~= nil then
        local angle_rad = math.pi * ligation.angle / 180
        x = dad_atom.x + math.cos(angle_rad) * STANDARD_LIGATION_SIZE
        y = dad_atom.y + math.sin(angle_rad) * STANDARD_LIGATION_SIZE
    end

    atom.x = x
    atom.y = y
    atom.already = true

    for idx, lig in ipairs(atom.ligations) do
        self:calcAtomsPosition(lig.to, atom, lig, idx, ligation)
    end
end

---draw the atoms
---@return Error?
function Plugin:drawAtom()
    return Error:new("Method drawAtom not Implemented")
end

---draw the ligations
---@return Error?
function Plugin:drawLigation()
    return Error:new("Method drawLigation not Implemented")
end

function Plugin:measureBounds()
    local min_x = 0
    local min_y = 0
    local max_x = 0
    local max_y = 0

    for _, atom in ipairs(self.atoms) do
        local x = atom["x"]
        local y = atom["y"]

        if atom["symbol"] == "X" then
            goto continue
        end

        if x > max_x then max_x = x end
        if y > max_y then max_y = y end
        if x < min_x then min_x = x end
        if y < min_y then min_y = y end

        ::continue::
    end

    local cwidth = max_x + -min_x
    local cheight = max_y + -min_y

    self.width = BORDER * 2 + cwidth
    self.height = BORDER * 2 + cheight

    self.center_x = BORDER + math.abs(min_x)
    self.center_y = BORDER + math.abs(min_y)

    return nil
end

function StandardPlugin:drawAtom()
    for _, atom in ipairs(self.atoms) do
        local symbol = atom["symbol"]
        local x = self.center_x + atom["x"]
        local y = self.center_y + atom["y"]

        if symbol == "X" then
            goto continue
        end

        self.svg:text(atom["symbol"], x, y)

        local charge = atom["charge"]

        if charge ~= 0 then
            if charge == 1 then
                charge = "+"
            end
            if charge == -1 then
                charge = "-"
            end
            self.svg:subtext(charge, x + STANDARD_ATOM_RADIUS, y - STANDARD_ATOM_RADIUS)
        end

        ::continue::
    end

    return nil
end

STANDARD_DISTANCE_BETWEEN_LIGATIONS = 20

STANDARD_WAVES = {
    { 0 },
    {STANDARD_DISTANCE_BETWEEN_LIGATIONS / 2, -STANDARD_DISTANCE_BETWEEN_LIGATIONS / 2},
    {STANDARD_DISTANCE_BETWEEN_LIGATIONS, 0, -STANDARD_DISTANCE_BETWEEN_LIGATIONS}
}

function StandardPlugin:drawLigation()
    for _, ligation in pairs(self.ligations) do
        local from_atom = ligation.from
        local to_atom = ligation.to

        if to_atom.symbol == "X" then
            goto continue
        end

        local ax = self.center_x + from_atom.x
        local ay = self.center_y + from_atom.y
        local bx = self.center_x + to_atom.x
        local by = self.center_y + to_atom.y

        local angles = STANDARD_WAVES[ligation.eletrons]

        local a_angle = math.atan((by - ay), (bx - ax))
        local b_angle = math.pi + a_angle

        if ligation.type ~= "iônica" then
            for _, angle in ipairs(angles) do
                local nax = ax + math.cos(a_angle - (math.pi * angle / 180)) * STANDARD_ATOM_RADIUS
                local nay = ay + math.sin(a_angle - (math.pi * angle / 180)) * STANDARD_ATOM_RADIUS

                local nbx = bx + math.cos(b_angle + (math.pi * angle / 180)) * STANDARD_ATOM_RADIUS
                local nby = by + math.sin(b_angle + (math.pi * angle / 180)) * STANDARD_ATOM_RADIUS

                self.svg:line(nax, nay, nbx, nby)
            end
        end

        ::continue::
    end

    return nil
end

local svg_content, err = StandardPlugin:build()
if err ~= nil then err:print() end

OUT_SVG_FILE = "out.svg"

local out_file = io.open(OUT_SVG_FILE, "w")
if not out_file then
    Error:new("Problemas ao criar arquivo de saída"):print()
    os.exit(1)
end
out_file:write(svg_content)
out_file:close()